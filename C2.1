8 primitive type 
4整型 2浮点型 1boolean型 1用于表示unicode编码的char型
int 4bytes (超过20亿) 
short 2byes
long 8biyes
byte 1byte
长整型可加后缀L 4000000000L
十六进制0x 八进制0 但是八进制的前缀容易混淆
二进制0b 数字字面量可以加下划线如1_000_000表示一百万，下划线只是为了容易阅读。编译器会自动去除这些下划线。
C和C++中int和处理器相关
float 4bytes 有效位数 6-7位
double 8bytes 有效位数15

三个特殊的浮点值用于表示溢出和出错：
正无穷大
负无穷大
NaN（不是一个数字）
例如正整数除以0结果无穷大。0/0或者负数的平方根是NaN。
Double.POSITIVE_INFINITE Double.NEGATIVE_INFINITE Double.NaN
检测x是不是一个NaN要
if(Double.isNaN(x))
下面的是错的
if(x == Double.NaN)// is never true

警告！WARINGN：
浮点数值不适用于禁止出现舍入运算的金融领域。例如System.out.println（2.0-1.1）将打印出0.8999999999999999999，而不是0.9。
主要原因是浮点数值采用二进制系统表示。二进制系统无法精确表示分数1/10。就像十进制无法精确表示1/3.
这种情况下应该使用 BigDecimal 类。

char类型用于表示单个字符。例如：'A'是编码65对应的字符常量。与"A"不同，"A"是一个包含字符A的字符串。Unicode编码单元可以表示为十六进制值，其范围从
\u0000到\uffff。例如：\u03C0表示希腊字母π
转义序列符号\u可以出现在字符常量或字符串的引号之外
public static void main(String \u005B\u005D args)
以上这种形式符合语法规则 \u005B和\u005D是[和]的编码

代码单元：UTF-8中是用8个字节表示的，UTF-16中使用16个字节表示的等等。
Char： 在java中是采用UTF-16编码的，也就是说，Char是代表一个代码单元。
代码点：对应各种真正字符（char不是真正的字符，是代码单元）的Unicode编码。一个代码点可能对应一对代码单元，如辅助字符。是指编码字符集中，字符所对应的数字。有效范围从U+0000到U+10FFFF。其中U+0000到U+FFFF为基本字符，U+10000到U+10FFFF为增补字符
也正是因为以上原因，在Java中，不赞成使用Char类型，因为它并不能代表一个真正的字符，而只是代码单元，而操作中，我们往往想得到的是真正的字符，而不是代码单元char。
对代码点进行编码得到的1或2个16位序列（UTF-16）。其中基本字符的代码点直接用一个相同值的代码单元表示，增补字符的代码点用两个代码单元进行编码，编码值来自U+D800到U+DFFF，这个范围内没有数字用于表示字符，因此程序可以识别出当前字符是单单元的基本字符，还是双单元的增补字符。
str.length()返回的的是采用UTF－16编码表示的给定字符串所需要的代码单元数量。
要想得到实际的长度即代码点数量，可以调用:
int  cpCount= str.codePointCount(0,str.length())

String a="\u03C0 \uD835\uDD6B";
	int b=a.codePointCount(0, a.length());
		System.out.println(b);              //3个
		System.out.println(a.length());     //4个
然后str.charAt(n)返回的是位置n的代码单元
要想得到第i个代码点:
int index = str.offsetByCodePoints(0,i)
int cp=str.codePointAt(index)//返回指定位置的unicode码值

遍历一个字符串，并且依次查看每个代码点:
int cp=str.codePointAt(i);
if(Character.isSupplementaryCodePoint(cp)) i+=2
else i++;
以下语句实现回退操作:
i--;
if(Character.isSurrogate(str.charAt(i)))i--;
in cp=str.codePointAt(i)

常量
final用来指示常量，一旦赋值不能更改。常量名使用全大写。
final double PI＝3.1415932653
在Java中，static final设置类常量，即静态常量。
public class SimpleSample{
  public static final double PI=3.14159// or private
  public static void main(String[] args)
  {
    …………//code goes here
  }
}
  
n++ 先运算在加一
++n 先加一在运算

condition ? expression1 : expression2
x < y ? x : y
条件为真返回走x，否则走y

数学函数
Math.sin() Math.exp() ……
数学常量
Math.PI Math.E
在源文件顶部加入 import static java.lang.Math.* 则可以不需要加前缀"Math"

数值类型转换
小字节类型的数值可以无损转换大字节类型
例如: float->double  byte->short->int->long
如果转换方向相反则会丢失一定精度

强制转换(cast)
double x=9.997
int nx= (int) x;// nx=9
可以对浮点数进行舍入运算，以便得到最接近的整数: Math.round
double x=9.997
int nx = (int) Math.round(x);// nx=10
ps:round返回类型为long所以需要强制转换int

枚举类型
enum Size{SMALL, MEDUIM, LARGE, EXTRA_LARGE};
此时可以声明这种类型的变量: 
Size s=Size.MEDUIM;
Size类型的变量只能存储在这个类型声明中给定的某个枚举值，或者null值。

字符串
从概念上来讲，Java字符串就是Unicode的字符序列。例如: 串“Java™”就是由5个Unicode字符J,a,v,a,和™。
Java没有内置的字符串类型，是在标准Java类库中提供了一个预定义类String。每个用双引号括起来的字符串都是String类的一个实例: 
String e = "";
String greeting="Hello"

子串
String gretting="Hello"
String s=greeting.substring(0,3);//s的值为"Hel"
substring方法的第二个参数是 不想 被复制的的起始位置。所以 s 只截取了0，1，2这三个字符

拼接
可直接使用 ＋ 号进行连接（拼接）两个字符串。

Inmutabe
Java字符串是不可修改的。但指向其的变量可以改变指向的内容。

检测字符串是否相等
s.equals(t)//相等返回true, 不等返回false。
s和t可为字符串变量或常量
"Hello".equalsIgnoreCase("hello")//不区分大小写比较
一定不能使用 == 运算符 因为这个运算符只能确定两个字符串是否放置在同一个位置上。

空串和Null串
str.length()==0 或者 str.equals("")
String 对象可以存放null表示目前没有任何对象与改变量关联。就和普通的类的对象置为null一样
检查字符串既不null也不空
if(str!=null && str.length()!=0)

Java API 联机文档:
http://docs.oracle.com/javase/7/docs/api/
目前只看到Java7没见到Java8

构建字符串
由较短的字符串构建字符串时，字符串连接的方式效率较低。每次连接都会构建一个新的String对象，耗时也浪费空间。这里使用StringBuilder类来避免这个问题。
StringBuilder builder=new StringBuilder();
当需要添加一部分内容调用append()方法
builder.append(ch);
builder.append(str);
需要构建字符串时，调用toString方法，就可以得道一个String对象，其中包含了builder中的字符序列
String completedString=builder.toString();

输入输出
打印输出到"标准输出流"调用System.out.println即可。读取"标准输入流"System.in，要先构造一个Scanner对象，并与"标准输入流"System.in关联。
Scanner in = new Scanner(System.in);
现在可以使用Scanner类的各种方法实现输入操作了。
